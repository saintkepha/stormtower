// Generated by CoffeeScript 1.7.1
(function() {
  var StormAgent, StormTower, async, crypto, http,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  http = require('http');

  async = require('async');

  crypto = require("crypto");

  StormAgent = require('stormagent');

  StormTower = (function(_super) {
    var activatedEndpoints, allEndPoints, httpReqSender, successStatusCodes;

    __extends(StormTower, _super);

    activatedEndpoints = [];

    allEndPoints = {
      globalChecksum: "",
      StormResponses: {}
    };

    successStatusCodes = [200, 202, 204, 304];

    function StormTower() {
      this.stormflashPolling = __bind(this.stormflashPolling, this);
      this.cnameDiscovery = __bind(this.cnameDiscovery, this);
      StormTower.__super__.constructor.apply(this, arguments);
      this["import"](module);
      this.log('[constructor] stormtower object instantiating');
      this.boltServerHost = GLOBAL.config.stormbolt.split(":")[0];
      this.boltServerPort = GLOBAL.config.stormbolt.split(":")[1];
      this.log('[constructor] stormbolt url: ', this.boltServerHost);
      this.log('[constructor] stormbolt port: ', this.boltServerPort);
      this.boltClientPort = 5000;
      this.pollingURL = '/';
      this.pollingDelayMsec = 2000;
      this.pollingIntvMsec = 5000;
      this.cnameDisOptions = {
        hostname: this.boltServerHost,
        port: this.boltServerPort,
        path: '/cname',
        method: 'GET',
        agent: false
      };
      this.cnamePollOptions = {
        hostname: this.boltServerHost,
        port: this.boltServerPort,
        path: '/',
        method: 'GET',
        agent: false
      };
    }

    StormTower.prototype.startPolling = function() {
      this.log('[startPolling] stormflash discovery is initiated');
      return setInterval(this.cnameDiscovery, this.pollingIntvMsec);
    };

    StormTower.prototype.cnameDiscovery = function() {
      var req;
      setTimeout(this.stormflashPolling, this.pollingDelayMsec);
      req = http.request(this.cnameDisOptions, function(res) {
        var result;
        result = '';
        res.on("data", function(chunk) {
          return result += chunk;
        });
        return res.on("end", function() {
          var cnameList, endpoints;
          cnameList = JSON.parse(result);
          activatedEndpoints = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = cnameList.length; _i < _len; _i++) {
              endpoints = cnameList[_i];
              _results.push(endpoints.cname);
            }
            return _results;
          })();
          return this.log('[cnameDiscovery] active stormflash list: ', activatedEndpoints);
        });
      });
      req.on("error", function(err) {
        this.log(err);
        return this.log('[ERROR] [cnameDiscovery] error ', err);
      });
      return req.end();
    };

    StormTower.prototype.stormflashPolling = function() {
      var boltClientPort, httpOptions, key, value, _ref;
      _ref = allEndPoints.StormResponses;
      for (key in _ref) {
        value = _ref[key];
        if (__indexOf.call(activatedEndpoints, key) < 0) {
          this.log("[stormflashPolling] " + key + " stormflash removed from master table");
          delete allEndPoints.StormResponses[key];
        }
      }
      httpOptions = this.cnamePollOptions;
      boltClientPort = this.boltClientPort;
      return async.each(activatedEndpoints, (function(cname, callback) {
        var boltHeaders, req;
        this.log("[stormflashPolling] " + cname + "] polling started");
        boltHeaders = {
          'stormbolt-target': "" + cname + ": " + boltClientPort
        };
        httpOptions.headers = boltHeaders;
        req = http.request(httpOptions, function(res) {
          var result;
          result = '';
          res.on("data", function(chunk) {
            return result += chunk;
          });
          return res.on("end", function() {
            var cnameDetails, md5, md5CheckSum, now, timeStamp;
            this.log("[stormflashPolling] " + cname + " response status ", res.statusCode);
            if (res.statusCode === 200) {
              cnameDetails = JSON.parse(result);
              md5 = crypto.createHash("md5");
              md5.update(result);
              md5CheckSum = md5.digest("hex");
              now = new Date;
              timeStamp = now.getUTCMonth() + ':' + now.getUTCDate() + ':' + now.getUTCFullYear() + ' ' + now.getUTCHours() + ':' + now.getUTCMinutes() + ':' + now.getUTCSeconds() + ' UTC';
              allEndPoints.StormResponses[cname] = {
                Response: cnameDetails,
                checksum: md5CheckSum,
                lastUpdated: timeStamp
              };
            } else {
              this.log("[stormflashPolling] " + cname + " stormflash removed from master table");
              delete allEndPoints.StormResponses[cname];
            }
            callback();
          });
        });
        req.on("error", function(err) {
          this.log("[stormflashPolling] " + cname + " error ", err);
          this.log("[stormflashPolling] " + cname + " stormflash removed from master table");
          delete allEndPoints.StormResponses[cname];
          callback(err + cname);
          return this.next;
        });
        return req.end();
      }), function(err) {
        var globalMD5, _ref1;
        if (err == null) {
          this.log('[stormflashPolling] polling successful');
        } else {
          this.log('[stormflashPolling] polling error ', err);
        }
        globalMD5 = crypto.createHash("md5");
        _ref1 = allEndPoints.StormResponses;
        for (key in _ref1) {
          value = _ref1[key];
          this.log('[stormflashPolling] adding md5 checksum of ', key);
          globalMD5.update(JSON.stringify(allEndPoints.StormResponses[key].Response));
        }
        allEndPoints.globalChecksum = globalMD5.digest("hex");
        this.log('[stormflashPolling] global md5 checksum ', allEndPoints.globalChecksum);
        this.log('---------------- MASTER TABLE ----------------');
        console.log(allEndPoints);
        this.log('------------------------------------------');
      });
    };

    StormTower.prototype.getPollingData = function(cnameList) {
      var cname, key, resObj, value, _i, _len;
      this.log('[getPollingData] cname list received: ' + cnameList);
      if (cnameList == null) {
        cnameList = (function() {
          var _ref, _results;
          _ref = allEndPoints.StormResponses;
          _results = [];
          for (key in _ref) {
            value = _ref[key];
            _results.push(key);
          }
          return _results;
        })();
        this.log('[getPollingData] cname list set to: ' + cnameList);
      }
      allEndPoints.globalChecksum = this.getGlobalChecksum(cnameList);
      resObj = {
        globalChecksum: allEndPoints.globalChecksum,
        agents: []
      };
      if (cnameList == null) {
        return allEndPoints.StormResponses;
      } else {
        for (_i = 0, _len = cnameList.length; _i < _len; _i++) {
          cname = cnameList[_i];
          resObj.agents.push({
            "cname": cname,
            "response": allEndPoints.StormResponses[cname].Response,
            "checksum": allEndPoints.StormResponses[cname].checksum,
            "lastUpdated": allEndPoints.StormResponses[cname].lastUpdated
          });
        }
        return resObj;
      }
    };

    StormTower.prototype.getGlobalChecksum = function(cnameList) {
      var cname, globalMD5, _i, _len;
      globalMD5 = crypto.createHash("md5");
      this.log('[getGlobalChecksum] received cname list ', cnameList);
      if (cnameList == null) {
        this.log('[getGlobalChecksum] returning the current global md5 checksum');
        return allEndPoints.globalChecksum;
      } else {
        for (_i = 0, _len = cnameList.length; _i < _len; _i++) {
          cname = cnameList[_i];
          this.log('[getGlobalChecksum] adding md5 checksum of ', cname);
          globalMD5.update(JSON.stringify(allEndPoints.StormResponses[cname].Response));
        }
        return globalMD5.digest("hex");
      }
    };

    httpReqSender = function(httpOptions, reqBody, timeout, cname, callback) {
      var inputData, req, returnObj, _ref;
      this.log("[httpReqSender] " + cname);
      returnObj = {
        status: 500,
        output: {}
      };
      inputData = JSON.stringify(reqBody);
      req = http.request(httpOptions, (function(_this) {
        return function(res) {
          var result;
          result = '';
          res.on("data", function(chunk) {
            return result += chunk;
          });
          return res.on("end", function() {
            var _ref;
            this.log("[httpReqSender] " + cname + " response status ", res.statusCode);
            returnObj.status = res.statusCode;
            if (_ref = res.statusCode, __indexOf.call(successStatusCodes, _ref) >= 0) {
              this.log("[httpReqSender] " + cname + " response: ", result);
              returnObj.output = JSON.parse(result);
            } else {
              if (result) {
                this.log("[httpReqSender] " + cname + " failure: ", result.split('\n')[0]);
                returnObj.output = {
                  error: result.split('\n')[0]
                };
              } else {
                returnObj.output = {
                  error: 'info not available'
                };
              }
            }
            return callback(returnObj);
          });
        };
      })(this));
      req.on("error", function(err) {
        this.log("[httpReqSender] " + cname + " error ", err);
        returnObj.output = {
          error: err
        };
        return callback(returnObj);
      });
      req.setTimeout(timeout, function(reply) {
        this.log("[httpReqSender] " + cname + " timeout: ");
        returnObj.status = 408;
        returnObj.output = {
          error: 'http request got timeout'
        };
        return callback(returnObj);
      });
      if (((_ref = httpOptions.method) === 'POST' || _ref === 'PUT') && inputData) {
        this.log("[httpReqSender] " + cname + " input data: ", inputData);
        req.write(inputData);
      }
      req.end();
      return this.log("[httpReqSender] " + cname + " request forwarded");
    };

    return StormTower;

  })(StormAgent);

  module.exports = function(args) {
    return new StormTower(args);
  };

}).call(this);
