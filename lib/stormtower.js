// Generated by CoffeeScript 1.7.1
(function() {
  var StormAgent, StormBolt, StormData, StormRegistry, StormTower, TowerMinion, TowerRegistry, agent, config, storm,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  StormAgent = require('stormagent');

  StormData = StormAgent.StormData;

  TowerMinion = (function(_super) {
    var async, crypto, http;

    __extends(TowerMinion, _super);

    async = require('async');

    http = require('http');

    crypto = require('crypto');

    function TowerMinion(id, bolt) {
      this.id = id;
      this.bolt = bolt;
      this.status = false;
      this.checksum = null;
      this.monitoring = false;
      TowerMinion.__super__.constructor.call(this, id);
    }

    TowerMinion.prototype.monitor = function(interval) {
      var extend;
      if (this.monitoring) {
        return;
      }
      extend = require('util')._extend;
      this.monitoring = true;
      return async.whilst((function(_this) {
        return function() {
          return _this.monitoring;
        };
      })(this), (function(_this) {
        return function(repeat) {
          var err, relay, req, streamBuffers;
          try {
            streamBuffers = require('stream-buffers');
            req = new streamBuffers.ReadableStreamBuffer;
            req.method = 'GET';
            req.url = '/status';
            req.target = 5000;
            _this.log("monitor - checking " + _this.bolt.id + " for status");
            relay = _this.bolt.relay(req);
            req.destroy();
            return relay.on('reply', function(reply) {
              var checksum, copy, err, md5, status;
              try {
                status = JSON.parse(reply.body);
                copy = extend({}, status);
                delete copy.os;
                md5 = crypto.createHash("md5");
                md5.update(JSON.stringify(copy));
                checksum = md5.digest("hex");
                if (checksum !== _this.checksum) {
                  _this.checksum = checksum;
                  if (!_this.status) {
                    _this.emit('ready');
                  }
                  _this.status = status;
                  return _this.emit('changed');
                }
              } catch (_error) {
                err = _error;
                _this.log("unable to parse reply:", reply);
                _this.log("error:", err);
                return relay.end();
              }
            });
          } catch (_error) {
            err = _error;
            _this.log("monitor - minion discovery request failed:", err);
            try {
              if (req != null) {
                return req.destroy();
              }
            } catch (_error) {
              err = _error;
              return _this.log("monitor - destroying request failed... (this should not happen)", err);
            }
          } finally {
            _this.log("monitor - scheduling repeat at " + interval);
            setTimeout(repeat, interval);
          }
        };
      })(this), (function(_this) {
        return function(err) {
          _this.log("monitor - minion discovery stopped for: " + _this.id);
          return _this.monitoring = false;
        };
      })(this));
    };

    TowerMinion.prototype.destroy = function() {
      return this.monitoring = false;
    };

    return TowerMinion;

  })(StormData);

  StormRegistry = StormAgent.StormRegistry;

  TowerRegistry = (function(_super) {
    __extends(TowerRegistry, _super);

    function TowerRegistry(filename) {
      this.on('removed', function(minion) {
        if (minion.destroy != null) {
          return minion.destroy();
        }
      });
      TowerRegistry.__super__.constructor.call(this, filename);
    }

    TowerRegistry.prototype.get = function(key) {
      var entry, _base;
      entry = TowerRegistry.__super__.get.call(this, key);
      if (!((entry != null) && (entry.status != null))) {
        return;
      }
      if ((_base = entry.status).id == null) {
        _base.id = entry.id;
      }
      return entry.status;
    };

    return TowerRegistry;

  })(StormRegistry);

  StormBolt = require('stormbolt');

  StormTower = (function(_super) {
    __extends(StormTower, _super);

    function StormTower(config) {
      StormTower.__super__.constructor.call(this, config);
      this["import"](module);
      this.minions = new TowerRegistry;
      this.clients.on('added', (function(_this) {
        return function(bolt) {
          var minion;
          minion = new TowerMinion(bolt.id, bolt);
          minion.monitor(_this.config.monitorInterval);
          return minion.once('ready', function() {
            _this.minions.add(bolt.id, minion);
            return minion.on('changed', function() {
              return _this.minions.emit('changed');
            });
          });
        };
      })(this));
      this.clients.on('removed', (function(_this) {
        return function(bolt) {
          _this.log("boltstream " + bolt.id + " is removed");
          return _this.minions.remove(bolt.id);
        };
      })(this));
    }

    StormTower.prototype.status = function() {
      var state;
      state = StormTower.__super__.status.apply(this, arguments);
      state.minions = this.minions.list();
      return state;
    };

    return StormTower;

  })(StormBolt);

  module.exports = StormTower;

  if (require.main === module) {
    console.log('stormtower rising up to stand against the coming storm...');

    /*
    argv = require('minimist')(process.argv.slice(2))
    if argv.h?
        console.log """
            -h view this help
            -p port number
            -l logfile
            -d datadir
        """
        return
    
    config = {}
    config.port    = argv.p ? 5000
    config.logfile = argv.l ? "/var/log/stormtower.log"
    config.datadir = argv.d ? "/var/stormstack"
     */
    config = null;
    storm = null;
    agent = new StormTower(config);
    agent.run(storm);
    if (typeof gc !== "undefined" && gc !== null) {
      setInterval((function() {
        return gc();
      }), 2000);
    }
  }

}).call(this);
